import { ethers } from "ethers";
import { Identity } from "@semaphore-protocol/identity";
import { Group }    from "@semaphore-protocol/group";
import {
    generateProof
} from "@semaphore-protocol/proof";

function packToSolidityProof(proof) {
    // proof.points ‚Äî –º–∞—Å—Å–∏–≤ –∏–∑ –≤–æ—Å—å–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç [Ax, Ay, Bx0, Bx1, By0, By1, Cx, Cy]
    const p = proof.points.map(x => BigInt(x));
    return [
        p[0], p[1],                  // A
        p[2], p[3], p[4], p[5],      // B
        p[6], p[7]                   // C
    ];
}

export async function loadIdentity(voteIdString, signer) {
    const sig = await signer.signMessage(`Generate Semaphore identity for ${voteIdString}`);
    return new Identity(sig);
}

export async function getIdentityCommitment(voteIdString, setIdentityCommitment, signer) {
    console.log("VoteId bytes32:", ethers.encodeBytes32String(voteIdString));
    const identity = await loadIdentity(voteIdString, signer);
    const identityCommitment = BigInt(identity.commitment);  // —ç—Ç–æ BigInt
    console.log("Identity Commitment:", identityCommitment);

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º BigInt –≤ —Å—Ç—Ä–æ–∫—É –≤ —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–æ–π —Ñ–æ—Ä–º–µ
    const identityCommitmentHex = ethers.toBeHex(identityCommitment, 32);

    console.log("Idenity Commitment Hex:", identityCommitmentHex);

    setIdentityCommitment(identityCommitmentHex);
}

export async function createVote(
    voteIdString,
    optionsCount,
    identityCommitments,
    votingDurationSec,
    votingContract,
) {
    console.log("typeof identityCommitments[0]:", typeof identityCommitments[0]);
    console.log("identityCommitments[0]:", identityCommitments[0]);
    // 1. –°–æ–±–∏—Ä–∞–µ–º Merkle-–≥—Ä—É–ø–ø—É
    const group = new Group(identityCommitments.map(c => BigInt(c)));
    const merkleRoot = BigInt(group.root);
    const merkleRootBytes32 = ethers.zeroPadValue(ethers.toBeHex(merkleRoot), 32);

    // 2. –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º args
    const voteId    = ethers.encodeBytes32String(voteIdString);
    const nowSec    = Math.floor(Date.now() / 1000);
    const votingEnd = nowSec + votingDurationSec;

    const identityCommitmentsBytes32 = identityCommitments.map((c) =>
        ethers.zeroPadValue(c, 32) // ‚Üê —ç—Ç–æ –ø—Ä–∏–≤–µ–¥—ë—Ç —Å—Ç—Ä–æ–∫—É '0x...' –∫ bytes32
    );

    // 3. –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
    const tx = await votingContract.createVote(
        voteId,
        identityCommitmentsBytes32,
        optionsCount,
        votingEnd,
        merkleRootBytes32,
    );
    console.log("createVote tx:", tx.hash);
    await tx.wait();
    console.log("‚úÖ Vote created");
}

export async function castVote(voteIdString, option, signer, votingContract) {
    console.log("Voting contract: ", votingContract);
    const voteId = ethers.encodeBytes32String(voteIdString);

    // 2.1) –ü–æ–ª—É—á–∞–µ–º Merkle-root, –∫–æ–Ω–µ—Ü –∏ —á–∏—Å–ª–æ –æ–ø—Ü–∏–π
    // const [merkleRoot, votingEnd, optionsCount] =
    //     await votingContract.getGroup(voteId);
    //
    // console.log("merkleRoot: ", merkleRoot);
    // console.log("votingEnd: ", votingEnd);
    // console.log("optionsCount: ", optionsCount);
    //
    // if (option >= optionsCount) throw new Error("Bad option");

    // 2.2) –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–æ–º–º–∏—Ç–º–µ–Ω—Ç–æ–≤ –∏–∑ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    const rawCommitments = await votingContract.getCommitments(voteId);
    console.log("rawCommitments received from contract:", rawCommitments);
    // rawCommitments ‚Äî Array<bytes32> ‚Üí BigInt-–º–∞—Å—Å–∏–≤:
    const commitments = rawCommitments.map(x => BigInt(String(x)));
    console.log("commitments received from contract:", commitments);

    // 2.3) –°–æ–±–∏—Ä–∞–µ–º Merkle-–≥—Ä—É–ø–ø—É
    const group = new Group(commitments);

    // 2.4) –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–ª–∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º user‚Äôs Identity
    const identity = await loadIdentity(voteIdString, signer);

    // 2.5) External nullifier = hash(voteIdString)
    const externalNullifier = BigInt(
        ethers.keccak256(
            ethers.toUtf8Bytes(voteIdString)
        )
    );

    // 2.6) –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º ZK-–ø—Ä—É—Ñ –∏ nullifierHash
    const proof = await generateProof(
        identity,
        group,
        option,            // signal
        externalNullifier  // nullifier scope
    );

    const nullifierHash = BigInt(String(proof.nullifier));
    console.log("nullifierHash: ", nullifierHash);
    console.log("option: ", option);

    // –≤–æ—Ç –∑–¥–µ—Å—å –≤—ã–∑—ã–≤–∞–µ–º:
    try {
        await votingContract.vote(
            voteId,
            option,
            proof,
        );
    } catch (e) {
        console.error("üß® Static call failed:", e);
    }
    // console.log("castVote tx:", tx.hash);
    // await tx.wait();
    // console.log("‚úÖ Vote cast");
}

export async function getResults(voteIdString, votingContract) {
    const voteId = ethers.encodeBytes32String(voteIdString);
    const results = await votingContract.getResults(voteId);
    console.log("results: ", results);
    return results;
}
